<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="前言是的，Promise长期让我处在懵逼状态。就像高中学不会化学，可是总有人跟你说：化学，不是很简单吗？（再见） 找了几篇文章看，把我拉出懵逼状态的是同事的一句话和一篇文章，特此记录。">
<meta property="og:type" content="article">
<meta property="og:title" content="Promise：从懵逼开始摸爬滚打">
<meta property="og:url" content="https://blog.kaolafed.com/2017/07/30/Promise：从懵逼开始摸爬滚打/index.html">
<meta property="og:site_name" content="考拉前端团队博客">
<meta property="og:description" content="前言是的，Promise长期让我处在懵逼状态。就像高中学不会化学，可是总有人跟你说：化学，不是很简单吗？（再见） 找了几篇文章看，把我拉出懵逼状态的是同事的一句话和一篇文章，特此记录。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-01-05T01:57:43.371Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Promise：从懵逼开始摸爬滚打">
<meta name="twitter:description" content="前言是的，Promise长期让我处在懵逼状态。就像高中学不会化学，可是总有人跟你说：化学，不是很简单吗？（再见） 找了几篇文章看，把我拉出懵逼状态的是同事的一句话和一篇文章，特此记录。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://blog.kaolafed.com/2017/07/30/Promise：从懵逼开始摸爬滚打/"/>





  <title>Promise：从懵逼开始摸爬滚打 | 考拉前端团队博客</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><a href="http://163.lu/SCYY62" target="_blank" class="site-advertise">
  <img src="https://haitao.nos.netease.com/50cd82c1-3fa4-47c4-bc97-b1fbfe5489b2.jpg" />
</a> 

<div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">考拉前端团队博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <a href="http://163.lu/SCYY62" target="_blank" class="main-qrcode"></a>
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blog.kaolafed.com/2017/07/30/Promise：从懵逼开始摸爬滚打/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="考拉前端团队">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://haitao.nos.netease.com/c8dd832b-900a-494f-91d7-3db1328a11f7.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="考拉前端团队博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Promise：从懵逼开始摸爬滚打
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-30T00:00:00+08:00">
                2017-07-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <!-- 为了更方便归档，请先完善以上信息，正文贴下面 -->
<!--
注意点：
0. 文章中的资源（主要是图片）引用请使用 HTTPS
1. 文章末可以加上自己的署名，如： by [Kaola](http://www.kaola.com)
2. 最好不要用 NOS 图床，感觉加防盗链是迟早的事
3. 文章会定期归档到 https://blog.kaolafed.com/
-->
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>是的，Promise长期让我处在懵逼状态。就像高中学不会化学，可是总有人跟你说：化学，不是很简单吗？（再见）</p>
<p>找了几篇文章看，把我拉出懵逼状态的是同事的一句话和一篇文章，特此记录。</p>
<a id="more"></a>
<h4 id="话：“-then-参数就是向前面的异步函数注册成功和失败的回调”"><a href="#话：“-then-参数就是向前面的异步函数注册成功和失败的回调”" class="headerlink" title="话：“.then()参数就是向前面的异步函数注册成功和失败的回调”"></a>话：“.then()参数就是向前面的异步函数注册成功和失败的回调”</h4><h4 id="文：-你不懂JS-异步与性能-第三章-Promises"><a href="#文：-你不懂JS-异步与性能-第三章-Promises" class="headerlink" title="文： 你不懂JS: 异步与性能 第三章: Promises"></a>文： <a href="https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/async%20&amp;%20performance/ch3.md" target="_blank" rel="noopener">你不懂JS: 异步与性能 第三章: Promises</a></h4><h2 id="我们经常写的异步回调出了什么问题？"><a href="#我们经常写的异步回调出了什么问题？" class="headerlink" title="我们经常写的异步回调出了什么问题？"></a>我们经常写的异步回调出了什么问题？</h2><ol>
<li>不好写不好看不好管理——引发对异步回调反感的直接原因。缺乏顺序性和可靠性。</li>
<li>callback代码流程是基于副作用的：一个函数会附带调用其他函数。</li>
<li>失去了对主流程的控制权，控制权在那些结果不可预测不可靠的代码块里。</li>
</ol>
<h4 id="如果异步代码只是告诉我们它是否完成，而能由我们把握流程，拿回调用回调的权利，那事情就会靠谱很多。"><a href="#如果异步代码只是告诉我们它是否完成，而能由我们把握流程，拿回调用回调的权利，那事情就会靠谱很多。" class="headerlink" title="如果异步代码只是告诉我们它是否完成，而能由我们把握流程，拿回调用回调的权利，那事情就会靠谱很多。"></a>如果异步代码只是告诉我们它是否完成，而能由我们把握流程，拿回调用回调的权利，那事情就会靠谱很多。</h4><h2 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise"></a>什么是Promise</h2><h3 id="未来的值"><a href="#未来的值" class="headerlink" title="未来的值"></a>未来的值</h3><p>文中的例子我觉得很棒，再此简单重复：</p>
<table>
<thead>
<tr>
<th>买汉堡</th>
<th>请求与回调</th>
</tr>
</thead>
<tbody>
<tr>
<td>去麦当劳，要了板烧堡套餐，27块给收银员</td>
<td>发请求</td>
</tr>
<tr>
<td>收银员给我号码牌198，保证我会得到汉堡</td>
<td>得到Promise</td>
</tr>
<tr>
<td>等待叫号，发了票圈“等会儿吃板烧堡了开心”（我还没有得到汉堡，但是号码牌已经代表了汉堡，相当于一个占位符，与什么时候得到它并没有关系）</td>
<td>等待并处理其他事物(可以使用这个<em>未来</em>的结果)</td>
</tr>
<tr>
<td>“198号，您的套餐齐了”</td>
<td><em>未来的值</em>已经返回，许诺换回了真值</td>
</tr>
<tr>
<td>“不好意思，我们的板烧堡卖完了”</td>
<td>返回<em>未来的值</em>可能成功也可能失败</td>
</tr>
<tr>
<td>WTF, 我的号码永远不被叫到</td>
<td>还有可能回调永远被搁置</td>
</tr>
</tbody>
</table>
<h3 id="现在和稍后的值"><a href="#现在和稍后的值" class="headerlink" title="现在和稍后的值"></a>现在和稍后的值</h3><ol>
<li><p>现在的值</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var x, y = 2;</div><div class="line">console.log(x + y);</div></pre></td></tr></table></figure>
<p> 第二步的打印是基于x,y都已经被解析，是<em>现在值</em></p>
</li>
<li><p>稍后的值</p>
<p> 如果x,y解析需要时间，解析之后再进行处理，这就需要回调</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function add(getX, getY, cb)&#123;</div><div class="line">    var x, y;</div><div class="line">    getX(function(xVal)&#123;</div><div class="line">        x = xVal;</div><div class="line">        if (y != undefined) &#123;</div><div class="line">            cb(x + y);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    getY(function(yVal)&#123;</div><div class="line">        y = yVal;</div><div class="line">        if (x != undefined) &#123;</div><div class="line">            cb(x + y);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">add(fetchX, fetchY, function(sum)&#123;</div><div class="line">    console.log(sum);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p> 从外部看，add()不关心现在x,y是否可用，内部将它们都当作未来的值。<strong>泛化</strong>了“现在”和“稍后”：所有的操作都变成异步的</p>
</li>
<li><p>Promise值</p>
<p> 用Promise来表达上面的例子</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function add(xPromise, yPromise)&#123;</div><div class="line">    return Promise.all([xPromise, yPromise])</div><div class="line">    .then(function(values)&#123;</div><div class="line">        return values[0] + values[1];</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// fetchX(), fetchY()分别为它们的值返回一个Promise</div><div class="line">add(fetchX(), fetchY())</div><div class="line">.then(function(sum)&#123;    // 链在add()里的then之后</div><div class="line">    console.log(sum);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p> 上面代码中有两层Promise</p>
<ol>
<li>fetchX(), fetchY()被直接调用传入add()，返回值都是Promise，表示在<em>现在</em>或者<em>稍后</em>准备好，都将行为泛化为与时间无关。</li>
<li><p>add()创建返回Promise。用.then()等待x, y被解析出来</p>
<h4 id="注意：Promise一旦被解析，就是外界不可变的，将解析值传给任何其他模块都是安全的，两个模块之间对解析值的监听互不干扰——不可变性。"><a href="#注意：Promise一旦被解析，就是外界不可变的，将解析值传给任何其他模块都是安全的，两个模块之间对解析值的监听互不干扰——不可变性。" class="headerlink" title="注意：Promise一旦被解析，就是外界不可变的，将解析值传给任何其他模块都是安全的，两个模块之间对解析值的监听互不干扰——不可变性。"></a>注意：Promise一旦被解析，就是外界不可变的，将解析值传给任何其他模块都是安全的，两个模块之间对解析值的监听互不干扰——不可变性。</h4></li>
</ol>
</li>
<li><p>完成事件</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function foo(x)&#123;</div><div class="line">    // do async things</div><div class="line">    return listener;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var evt = foo(&apos;result&apos;);</div><div class="line"></div><div class="line">evt.on(&apos;completion&apos;, function(val)&#123;</div><div class="line">    // do next tings width val</div><div class="line">&#125;);</div><div class="line"></div><div class="line">evt.on(&apos;failure&apos;, function(err)&#123;</div><div class="line">    // log wrong</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p> 将程序的控制权归还给调用方代码，一个耗时的函数在完成时发出通知，而不必关心外界的监听和处理</p>
</li>
<li><p>Promise“事件”</p>
<p> evt的监听能力是一个Promise的类比。</p>
<p> 在基于Promise的方式中，foo()会返回一个Promise实例。.then()注册了异步函数完成和拒绝事件</p>
</li>
</ol>
<h2 id="Promise的信任"><a href="#Promise的信任" class="headerlink" title="Promise的信任"></a>Promise的信任</h2><p>Promise是为什么，以及如何被设计为来解决<em>控制倒转</em>的信任问题</p>
<p>当你传递一个回调给一个工具函数foo()，它可能：</p>
<ol>
<li>调用回调太早</li>
<li>调用回调太晚（或者根本不调）</li>
<li>调用回调太多或太少</li>
<li>没能传递必要的参数和环境</li>
<li>吞掉了任何可能发生的错误/异常</li>
</ol>
<h3 id="调的太早"><a href="#调的太早" class="headerlink" title="调的太早"></a>调的太早</h3><p>即便是立即完成的Promise也不能被同步地监听<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">new Promise(function(resolve)&#123;</div><div class="line">    resolve(42);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>即使在Promise调用then的时候已经被解析了，then中的回调也总是被异步地调用</p>
<h3 id="调得太晚"><a href="#调得太晚" class="headerlink" title="调得太晚"></a>调得太晚</h3><p>在resolve()或reject()被Promise创建机制调用的时候，注册在.then上的监听回调将会自动地被排程。这些被排程好的回调将在下一个异步时刻被可预测地触发。</p>
<p>当一个Promise被解析的时候，所有注册在then()上的回调都会被<strong>立即</strong>、按顺序地在下一个异步机会时被调用，且 没有任何在这些回调中发生的事情可以影响/推迟其他回调的调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var p = new Promise(function(resolve, reject)&#123;&#125;);</div><div class="line"></div><div class="line">p.then(function(val)&#123;</div><div class="line">    p.then(function()&#123;</div><div class="line">        console.log(&apos;c: &apos;, val);    // c不能干扰并优先于b</div><div class="line">    &#125;);</div><div class="line">    console.log(&apos;a: &apos;, val);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p.then(function(val)&#123;</div><div class="line">    console.log(&apos;b: &apos;, val);</div><div class="line">&#125;);</div><div class="line">// a b c</div></pre></td></tr></table></figure>
<h4 id="Promise排程的怪象"><a href="#Promise排程的怪象" class="headerlink" title="Promise排程的怪象"></a>Promise排程的怪象</h4><p>链接在两个分离的Promise上的回调之间的相对顺序是无法可靠预测的。</p>
<p>如果两个Promise p1和p2都准备好被解析了，那么p1.then(); p2.then()应当归结为首先调用p1的回调，然后调用p2的回调。但是有时候情况是下面这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">var p3 = new Promise(function(resolve, reject)&#123;</div><div class="line">    resolve(&apos;A&apos;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var p1 = new Promise(function(resolve, reject)&#123;</div><div class="line">    resolve(p3);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var p2 = new Promise(function(resolve, reject)&#123;</div><div class="line">    resolve(&apos;B&apos;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"></div><div class="line">p1.then(function(v)&#123;</div><div class="line">    console.log(v);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p2.then(function(v)&#123;</div><div class="line">    console.log(v);</div><div class="line">&#125;);</div><div class="line">// B A</div></pre></td></tr></table></figure></p>
<p>p1不是被一个立即值所解析的，而是由另一个promise p3所解析，p3被一个立即值“A”解析。这种行为将p3展开到p1，但是是异步的。在异步队列中，p1的回调位于p2的回调之后。</p>
<p>这是很微妙的噩梦，不应该依靠任何跨Promise的回调顺序/排程</p>
<h3 id="根本不调回调"><a href="#根本不调回调" class="headerlink" title="根本不调回调"></a>根本不调回调</h3><p>Promise有几种解决方式</p>
<ol>
<li>没有任何东西可以阻止Promise通知你它的解析。如果在Promise上注册了完成和拒绝回调，解析完成之后总有一个会被调用</li>
<li><p>如果Promise本身无论如何没有被解析呢？Promise使用了一个成为“竞赛(race)”的高级抽象</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// 一个使Promise超时的工具</div><div class="line">function timeoutPromise(delay) &#123;</div><div class="line">	return new Promise(function(resolve,reject)&#123;</div><div class="line">		setTimeout(function()&#123;</div><div class="line">			reject( &quot;Timeout!&quot; );</div><div class="line">		&#125;, delay);</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 为`foo()`设置一个超时</div><div class="line">Promise.race( [</div><div class="line">	foo(),					// 尝试调用`foo()`</div><div class="line">	timeoutPromise( 3000 )	// 给它3秒钟</div><div class="line">] )</div><div class="line">.then(</div><div class="line">	function()&#123;</div><div class="line">		// `foo(..)`及时地完成了！</div><div class="line">	&#125;,</div><div class="line">	function(err)&#123;</div><div class="line">		// `foo()`不是被拒绝了，就是它没有及时完成</div><div class="line">		// 那么可以考察`err`来知道是哪种情况</div><div class="line">	&#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<p> 这种超时模式有细节待考察，但是可以确保有delay的信号作为foo的结果，防止其无限地挂起我们的程序</p>
</li>
</ol>
<h3 id="调太少或太多次"><a href="#调太少或太多次" class="headerlink" title="调太少或太多次"></a>调太少或太多次</h3><p>太少：不被调用，上面已经说过<br>太多：Promise只能被解析一次。如果Promise的创建代码试着调用resolve()或reject()许多次，或者尝试用时调它们两个，Promise只接受第一次解析，而无声地忽略后面的尝试</p>
<p>因为Promise只能被解析一次，所以任何在then()上注册的回调函数将仅被调用一次。</p>
<h3 id="没能传入任何参数-环境"><a href="#没能传入任何参数-环境" class="headerlink" title="没能传入任何参数/环境"></a>没能传入任何参数/环境</h3><p>Promise可以拥有最多一个解析值（完成或拒绝）。</p>
<p>如果没有用一个值明确地解析它，解析值就是undefined。不管是什么值都会被传入所注册的（且适当的：完成或拒绝）回调中，不管是现在还是未来。</p>
<p>参数，如果你使用多个参数调用resolve()或者reject()，所有第一个参数之外的后续参数都会被无声忽略。如果想传递多个值，必须将它们包装在另一个单独的值array或者object</p>
<p>环境，JS函数总是保持他们被定义时所在作用域的闭包，所以它们理所当然地可以继续访问你提供的环境状态。</p>
<h3 id="吞掉所有错误-异常"><a href="#吞掉所有错误-异常" class="headerlink" title="吞掉所有错误/异常"></a>吞掉所有错误/异常</h3><p>如果你用一个 理由（也就是错误消息）拒绝一个Promise，这个值就会被传入拒绝回调。</p>
<p>更重要的事：如果在Promise的创建过程中的任意一点，或者在监听它的解析的过程中，一个JS异常错误发生的话，比如TypeError或ReferenceError，这个异常将会被捕获，并且强制当前的Promise变为拒绝。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var p = new Promise( function(resolve,reject)&#123;</div><div class="line">	foo.bar();	// `foo`没有定义，所以这是一个错误！</div><div class="line">	resolve( 42 );	// 永远不会跑到这里 :(</div><div class="line">&#125; );</div><div class="line"></div><div class="line">p.then(</div><div class="line">	function fulfilled()&#123;</div><div class="line">		// 永远不会跑到这里 :(</div><div class="line">	&#125;,</div><div class="line">	function rejected(err)&#123;</div><div class="line">		// `err`将是一个来自`foo.bar()`那一行的`TypeError`异常对象</div><div class="line">	&#125;</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>如果Promise完成了，在监听过程中（在then上注册的回调上）出现了异常错误也不会丢失，只是处理方式比较特别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var p = new Promise( function(resolve,reject)&#123;</div><div class="line">	resolve( 42 );</div><div class="line">&#125; );</div><div class="line"></div><div class="line">p.then(</div><div class="line">	function fulfilled(msg)&#123;</div><div class="line">		foo.bar();</div><div class="line">		console.log( msg );	// 永远不会跑到这里 :(</div><div class="line">	&#125;,</div><div class="line">	function rejected(err)&#123;</div><div class="line">		// 也永远不会跑到这里 :(</div><div class="line">	&#125;</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>foo.bar()发生的异常看起来被吞掉了，其实并没有。但更深层次的东西出问题了，也就是我们没能成功地监听他。</p>
<p>p.then()调用本身返回另一个Promise，是那个Promise将会被foo.bar()的TypeError异常拒绝。</p>
<p>为什么不能调用rejected(err)？因为违反了“Promise一旦被解析就<strong>不可变</strong>”的原则。p已经完成为值42，所以不能在监听p的解析时发生错误，在稍后又变成一个拒绝。</p>
<h3 id="可信的Promise？"><a href="#可信的Promise？" class="headerlink" title="可信的Promise？"></a>可信的Promise？</h3><p>基于Promise模式建立信任，还有最后一个细节需要考察。Promise根本没有摆脱回调，只是改变了回调传递的位置。与将一个回调函数传入foo()相反，我们从foo()拿回某些东西，然后我们将回调传入这个东西。</p>
<p>为什么这比直接传入回调可靠？因为 Promise.resolve()</p>
<p>如果传递一个立即的、非Promise的、非thenable的值给Promise.resolve()，你会得到一个用这个值完成的Promise。下面两个Promise p1和p2的行为基本上完全相同：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var p1 = new Promise( function(resolve,reject)&#123;</div><div class="line">	resolve( 42 );</div><div class="line">&#125; );</div><div class="line"></div><div class="line">var p2 = Promise.resolve( 42 );</div></pre></td></tr></table></figure></p>
<p>如果你传递一个纯粹的Promise给Promise.resolve()你会得到一个完全相同的Promise：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var p1 = Promise.resolve( 42 );</div><div class="line"></div><div class="line">var p2 = Promise.resolve( p1 );</div><div class="line"></div><div class="line">p1 === p2; // true</div></pre></td></tr></table></figure></p>
<p>更重要的是如果你传递一个非Promise的thenable值给Promise.resolve()，它会试着展开这个值，而且直到抽出一个最终具体的非Promise值之前，展开会继续下去。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var p = &#123;</div><div class="line">	then: function(cb,errcb) &#123;</div><div class="line">		cb( 42 );</div><div class="line">		errcb( &quot;evil laugh&quot; );</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">p</div><div class="line">.then(</div><div class="line">	function fulfilled(val)&#123;</div><div class="line">		console.log( val ); // 42</div><div class="line">	&#125;,</div><div class="line">	function rejected(err)&#123;</div><div class="line">		// 噢，这里本不该运行</div><div class="line">		console.log( err ); // evil laugh</div><div class="line">	&#125;</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>p是一个thenable但不是一个纯粹的Promise。我们可以将这两个版本的p传入Promise.resolve()，会得到一个期望的泛化、安全的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Promise.resolve( p )</div><div class="line">.then(</div><div class="line">	function fulfilled(val)&#123;</div><div class="line">		console.log( val ); // 42</div><div class="line">	&#125;,</div><div class="line">	function rejected(err)&#123;</div><div class="line">		// 永远不会跑到这里</div><div class="line">	&#125;</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>Promise.resolve()会接受任何thenable，得到一个真正的、纯粹的Promise，一个可以信任的东西。反正过滤之后是没有坏处的。</p>
<p>如果在调用一个foo()工具，而且不能确定我们能相信它的返回值是一个行为规范的Promise，但我们知道它是一个thenable。Promise.resolve()将会给我们一个可靠的Promise包装器来进行链式调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 不要只是这么做：</div><div class="line">foo( 42 )</div><div class="line">.then( function(v)&#123;</div><div class="line">	console.log( v );</div><div class="line">&#125; );</div><div class="line"></div><div class="line">// 相反，这样做：</div><div class="line">Promise.resolve( foo( 42 ) )    // 确保总是返回Promise，将函数调用泛化为一个行为规范的异步任务</div><div class="line">.then( function(v)&#123;</div><div class="line">	console.log( v );</div><div class="line">&#125; );</div></pre></td></tr></table></figure></p>
<h2 id="链式流程"><a href="#链式流程" class="headerlink" title="链式流程"></a>链式流程</h2><p>Promise不仅仅是一个单步的 this and then的操作机制，而是构建块。可以将多个Promise串联在一起表达一系列的异步步骤。是一种代码结构和流程。</p>
<p>Promise的核心作用就在于拉平了callback hell的洋葱结构，错误处理和Promise链。规范了异步编程的标准。</p>
<p>Promise的两个固有行为：</p>
<ol>
<li>在一个Promise上调用then()的时候，都创建并返回一个新的Promise，可以在上面进行链接。</li>
<li>无论从then()中的resolve()中返回什么值，都被作为链接的Promise的完成。</li>
</ol>
<p>Promise.resolve()传递一个Promise或thenable时，会直接返回纯粹的Promise或是展开收到的thenable的值——并且递归地持续展开thenable。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var p = Promise.resolve( 21 );</div><div class="line"></div><div class="line">p.then( function(v)&#123;</div><div class="line">	console.log( v );	// 21</div><div class="line"></div><div class="line">	// 创建一个promise并返回它</div><div class="line">	return new Promise( function(resolve,reject)&#123;</div><div class="line">		// 使用值`42`完成</div><div class="line">		resolve( v * 2 );</div><div class="line">		</div><div class="line">		// 引入异步也是一样正常工作！</div><div class="line">		// setTimeout(function()&#123;</div><div class="line">		//     // 使用值`42`完成</div><div class="line">		//     resolve(v*2);</div><div class="line">		// &#125;, 100);</div><div class="line">	&#125; );</div><div class="line">&#125; )</div><div class="line">.then( function(v)&#123;</div><div class="line">	console.log( v );	// 42</div><div class="line">&#125; );</div></pre></td></tr></table></figure></p>
<p>要是Promise链中的某一步出错了会怎样呢？一个错误/异常是基于每个Promise的，意味着在链条的任意一点捕获这些错误是可能的，而且这些捕获操作在那一点上将链条“重置”，使它回到正常的操作上来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// 步骤 1:</div><div class="line">request( &quot;http://some.url.1/&quot; )</div><div class="line"></div><div class="line">// 步骤 2:</div><div class="line">.then( function(response1)&#123;</div><div class="line">	foo.bar(); // 没有定义，错误！</div><div class="line"></div><div class="line">	// 永远不会跑到这里</div><div class="line">	return request( &quot;http://some.url.2/?v=&quot; + response1 );</div><div class="line">&#125; )</div><div class="line"></div><div class="line">// 步骤 3:</div><div class="line">.then(</div><div class="line">	function fulfilled(response2)&#123;</div><div class="line">		// 永远不会跑到这里</div><div class="line">	&#125;,</div><div class="line">	// 拒绝处理器捕捉错误</div><div class="line">	function rejected(err)&#123;</div><div class="line">		console.log( err );	// 来自 `foo.bar()` 的 `TypeError` 错误</div><div class="line">		return 42;          // 完成下一步（第4步）的promise，如此整个链条又回到完成的状态</div><div class="line">	&#125;</div><div class="line">)</div><div class="line"></div><div class="line">// 步骤 4:</div><div class="line">.then( function(msg)&#123;</div><div class="line">	console.log( msg );		// 42</div><div class="line">&#125; );</div></pre></td></tr></table></figure></p>
<p>如果你在一个promise上调用then(..)，而且你只向它传递了一个完成处理器，一个假定的拒绝处理器会取而代之：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var p = new Promise( function(resolve,reject)&#123;</div><div class="line">	reject( &quot;Oops&quot; );</div><div class="line">&#125; );</div><div class="line"></div><div class="line">var p2 = p.then(</div><div class="line">	function fulfilled()&#123;</div><div class="line">		// 永远不会跑到这里</div><div class="line">	&#125;</div><div class="line">	// 如果忽略或者传入任何非函数的值，</div><div class="line">	// 会有假定有一个这样的拒绝处理器</div><div class="line">	// function(err) &#123;</div><div class="line">	//     throw err;</div><div class="line">	// &#125;</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>如你所见，这个假定的拒绝处理器仅仅简单地重新抛出错误，它最终强制p2（链接着的promise）用同样的错误进行拒绝。实质上，它允许错误持续地在Promise链上传播，直到遇到一个明确定义的拒绝处理器。完成处理器缺失也是一样的原理，会有一个默认的处理器取而代之直到遇到明确定义的完成处理器</p>
<p>复习一下：使链式流程控制成为可能的Promise固有行为</p>
<ol>
<li>在一个Promise上的.then()调用会自动生成一个新的Promise并返回。</li>
<li>在完成/拒绝处理器内部，如果你返回一个值或抛出一个异常，新返回的Promise（可以被链接的）将会相应地被解析。</li>
<li>如果完成或拒绝处理器返回一个Promise，它会被展开，所以无论它被解析为什么值，这个值都将变成从当前的.then()返回的被链接的Promise的解析。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/async%20&amp;%20performance/ch3.md" target="_blank" rel="noopener">你不懂JS: 异步与性能 第三章: Promises</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/24444262" target="_blank" rel="noopener">最后谈一次 JavaScript 异步编程</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/07/29/svg图标在种草社区项目里的实践/" rel="next" title="svg图标在种草社区项目里的实践">
                <i class="fa fa-chevron-left"></i> svg图标在种草社区项目里的实践
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/07/31/「译」PromisesA+规范/" rel="prev" title="「译」Promises/A+规范">
                「译」Promises/A+规范 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://haitao.nos.netease.com/c8dd832b-900a-494f-91d7-3db1328a11f7.png"
               alt="考拉前端团队" />
          <p class="site-author-name" itemprop="name">考拉前端团队</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">105</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#话：“-then-参数就是向前面的异步函数注册成功和失败的回调”"><span class="nav-number">1.1.</span> <span class="nav-text">话：“.then()参数就是向前面的异步函数注册成功和失败的回调”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文：-你不懂JS-异步与性能-第三章-Promises"><span class="nav-number">1.2.</span> <span class="nav-text">文： 你不懂JS: 异步与性能 第三章: Promises</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#我们经常写的异步回调出了什么问题？"><span class="nav-number"></span> <span class="nav-text">我们经常写的异步回调出了什么问题？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#如果异步代码只是告诉我们它是否完成，而能由我们把握流程，拿回调用回调的权利，那事情就会靠谱很多。"><span class="nav-number">0.1.</span> <span class="nav-text">如果异步代码只是告诉我们它是否完成，而能由我们把握流程，拿回调用回调的权利，那事情就会靠谱很多。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是Promise"><span class="nav-number"></span> <span class="nav-text">什么是Promise</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#未来的值"><span class="nav-number">1.</span> <span class="nav-text">未来的值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#现在和稍后的值"><span class="nav-number">2.</span> <span class="nav-text">现在和稍后的值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#注意：Promise一旦被解析，就是外界不可变的，将解析值传给任何其他模块都是安全的，两个模块之间对解析值的监听互不干扰——不可变性。"><span class="nav-number">2.1.</span> <span class="nav-text">注意：Promise一旦被解析，就是外界不可变的，将解析值传给任何其他模块都是安全的，两个模块之间对解析值的监听互不干扰——不可变性。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Promise的信任"><span class="nav-number"></span> <span class="nav-text">Promise的信任</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#调的太早"><span class="nav-number">1.</span> <span class="nav-text">调的太早</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调得太晚"><span class="nav-number">2.</span> <span class="nav-text">调得太晚</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise排程的怪象"><span class="nav-number">2.1.</span> <span class="nav-text">Promise排程的怪象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#根本不调回调"><span class="nav-number">3.</span> <span class="nav-text">根本不调回调</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调太少或太多次"><span class="nav-number">4.</span> <span class="nav-text">调太少或太多次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#没能传入任何参数-环境"><span class="nav-number">5.</span> <span class="nav-text">没能传入任何参数/环境</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#吞掉所有错误-异常"><span class="nav-number">6.</span> <span class="nav-text">吞掉所有错误/异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可信的Promise？"><span class="nav-number">7.</span> <span class="nav-text">可信的Promise？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链式流程"><span class="nav-number"></span> <span class="nav-text">链式流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number"></span> <span class="nav-text">参考</span></a></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">考拉前端团队</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
